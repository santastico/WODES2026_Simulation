//  Author: Gabriel S. Pereira
//  Supervised by: C. A. Maia
//  Date: January 18, 2026

//  You need to include:
// ==>Number of signals
// ==>Restrictions and Cooperations between them
// ==>Time for each signal color
// ==>Initial state

// Clear Command Window
clc();

// Creation of a variable to measure the execution time
tic();

// Number of signals from the system

                p = 5;  //INPUT

// Restriction Matrix
// If I have M_rst(i, j) = 1, it is the same as saying that 
// signal i cannot open if signal j is open, that is, 
// the second transition (opening) of signal i only happens 
// after the first transition (closing) of signal j. 
// Additionally, the second transition of signal j only happens
// after the first transition of signal i.

M_rst = zeros(p,p);

                M_rst(1,4)=1;
                M_rst(4,5)=1;
                M_rst(5,2)=1;

// CoOperation Matrix
// If I have M_cop(i, j) = 1, it is the same as saying that
// signal i cannot open if signal j is closed, that is,
// the second transition (opening) of signal i only happens
// after the second transition (opening) of signal j.
// Additionaly, the first transition of signal j only happens
// after the first transition of signal i.

M_cop = zeros(p,p);

                M_cop(5,3)=1;
                M_cop(2,3)=1;

// Number of firings to be dated

                k = 5;  //INPUT

//----------------------------------------------------------------------------//
// Initialization of the delay time matrix
// Row = Signal
// Column = yellow | red | green

T = #(zeros(p, 3)); T(:) = %0;

            //INPUT

        T(1:p, 1) = 4;

        T(:, 2) = [49; 36; 27; 71; 84];
        T(:, 3) = [67; 80; 89; 45; 32];

//----------------------------------------------------------------------------//
// Initialization or initial state
// Row = Signal
// Column = yellow | red | green
// Per example, if M_0(7,3) == 1, so signal 7 is green

            //INPUT

        M_0(:, 1) = [0; 0; 0; 0; 0]; //TRFC. Light in yellow:
        M_0(:, 2) = [1; 0; 0; 0; 1]; //TRFC. Light in red   : 1,5   
        M_0(:, 3) = [0; 1; 1; 1; 0]; //TRFC. Light in green : 2,3,4  

//----------------------------------------------------------------------------//
// What happens after the failed transition. 
// k_fl = k-th transition, when fail occurs
// fl = transition to be modified
// Per example, if k_fl=3 and fl=11, the 11 transition during the k_fl-th execution
// will sufer a delay 

z=#(zeros(3 * p,1)); z(:)=%1; 

k_fl=ceil(k*rand());
k_fl=2;

fl=ceil((3*p)*rand());
fl=7;

//If you do not want an error, set k_fl=0;
//k_fl=0;

//Correction of k_fl and fl
//k_fl : 1 < k_fl < k
//fl must be after a place, that HAS a ticket

if k_fl == 1 then
    k_fl = k_fl + 1;
elseif k_fl == k then
    k_fl = k_fl - 1;
end;

for i=1 : p 
    if (((i * 3 - 2) <= fl) & (fl <= (i * 3)) & M_0(i,1)) then
            fl = i * 3;
    elseif (((i * 3 - 2) <= fl) & (fl <= (i * 3)) & M_0(i,2)) then
            fl = i * 3 - 2;
    elseif (((i * 3 - 2) <= fl) & (fl <= (i * 3)) & M_0(i,3)) then
            fl = i * 3 - 1;
    end,
end;

//LOGIC STARTS HERE        
//----------------------------------------------------------------------------//
// Initialization of the A_0 and A_1 matrix 

A_0 = #(zeros(3 * p, 3 * p)); A_0(:) = %0;
A_1 = #(zeros(3 * p, 3 * p)); A_1(:) = %0;

for i = 1:p,
    if M_0(i, 2) then
        A_0(i * 3 - 2, i * 3) = T(i, 1);
        A_0(i * 3, i * 3 - 1) = T(i, 3);
        A_1(i * 3 - 1, i * 3 - 2) = T(i, 2);                                
    elseif M_0(i, 3) then
        A_0(i * 3 - 2, i * 3) = T(i, 1);
        A_0(i * 3 - 1, i * 3 - 2) = T(i, 2);
        A_1(i * 3, i * 3 - 1) = T(i, 3);                      
    elseif M_0(i, 1) then
        A_0(i * 3 - 1, i * 3 - 2) = T(i, 2);
        A_0(i * 3, i * 3 - 1) = T(i, 3);
        A_1(i * 3 - 2, i * 3) = T(i, 1);  
    end,
end;

//----------------------------------------------------------------------------//
// Initialization of the L_0 and L_1 matrix 

L_0 = #(zeros(3 * p, 3 * p)); L_0(:) = %0;
L_1 = #(zeros(3 * p, 3 * p)); L_1 (:) = %0;

for i = 1:p,
    for j = 1:p,
        if ( ( M_rst(i, j) & M_0(i, 2) & M_0(j, 3) ) | ( M_rst(i, j) & M_0(i, 3) & M_0(j, 2) ) ) then
            L_0(i * 3 - 1, j * 3 - 2) = %1;
            L_0(j * 3 - 1, i * 3 - 2) = %1;
        
        elseif (M_rst(i, j) & M_0(i, 2) & M_0(j, 2) ) then
            L_1(i * 3 - 1, j * 3 - 2) = %1;
            L_1(j * 3 - 1, i * 3 - 2) = %1;
        
        elseif (M_cop(i, j) & M_0(i, 3) & M_0(j, 3) ) then 
            L_0(i * 3 - 1, j * 3 - 1) = %1;
            L_0(j * 3 - 2, i * 3 - 2) = %1;
        
        elseif (M_cop(i, j) & M_0(i, 2) & M_0(j, 3) ) then
            L_1(i * 3 - 1, j * 3 - 1) = %1;
            L_1(j * 3 - 2, i * 3 - 2) = %1;
        end,
    end,
end;

//----------------------------------------------------------------------------//


A_2=%eye(3*p,3*p);

A_2=#(A_2);

for j=1:3*p,
    A_2=A_2+(A_0+L_0)^j;
end;

A = A_2 * (A_1 + L_1);

// Matrix X0 (Initial Condition of the system)
[M, LB] = eigenspace(A);

        // M (Eigenvectors of matrix A) -> Enable an initial condition
        // LB (Eigenvalue of matrix A) -> System cycle
        
[l,c]=size(M);

e = zeros(c, 1);

X0 = M * e; // X0 currently has negative dates

Min_x0 = -1 * min(plustimes(X0));

Min_x0 = #(Min_x0);

X0 = Min_x0 * X0; // X0 corrected with a shift of Min_x0

X = #(zeros(3 * p, k)); X(:,:) = %0;

X(:,1) = X0;

Fmax= (LB*X0)/X0  // Global Controller

for i = 2:k,
    // X(:, i) = A* X(:, i - 1);
    if i==k_fl then
        z(fl)=X(fl,i-1)*1200;
    end,
    X(:, i) = Fmax* X(:, i - 1)+A_2*z;
     
end;

//X(i,j) is the matrix where i is the transition and j is the k-th date

//----------------------------------------------------------------------------//
// Creating a visual and meaningful terminal 
// To print the K-th fire dates of a Traffic Light

for i = 1:p
    tl_disp = 3 * i;
    tl_in_matrix = "Trfc Light " + string(i) + " || ";

    x_disp = zeros(4,k+1);

    for j = 1:k,
        x_disp(1,j+1) = j;
        x_disp(2,j+1) = X(tl_disp-2,j);
        x_disp(3,j+1) = X(tl_disp-1,j);
        x_disp(4,j+1) = X(tl_disp,j);
    end;

    x_disp = string(x_disp);
    x_disp(1,1) = tl_in_matrix;
    x_disp(2,1) = "Red ----------> ";
    x_disp(3,1) = "Green --------> ";
    x_disp(4,1) = "Yellow -------> ";
    
    //Terminal:
    //Traffic Light being analyzed
    disp(x_disp);
    
    disp("----------------------------------------------------------------------------------------------------");
    
end;

// System Cycle
disp("Cycle (in seconds): " + string(LB));

// Execution time
disp("Execution Time: " + string(toc()));

// Graphs
// Load the data
Data = plustimes(X);

// Select the indices of the desired signals (example: Signal 5, 3, and 2)
selected_signals = [1,2,3,4,5];

//-------------------------------------------------------------------------%
// Number of signals
num_signals = size(Data, "r") / 3;

// Create the main figure
scf(0); // Open a new figure

// Subplot counter
subplot_idx = 1;

// Iterate through the selected signals
for signal = selected_signals

    // Extract the transitions of the current signal (Red, Green, Yellow)
    // Transitions stores the k-data block of the current signal
    transitions = Data((signal - 1) * 3 + 1 : signal * 3, :);

    // Determine the smallest time and the corresponding initial state for the signal
    [min_time, min_idx] = min(transitions(:, 1)); // Smallest value and corresponding row
    if min_idx == 1 then
        current_state = 0.5;    // Red line: initial state is yellow
    elseif min_idx == 2 then
        current_state = 0;      // Green line: initial state is red
    else
        current_state = 1;      // Yellow line: initial state is green
    end

    // Initialize time and state arrays
    times = [0];                // Start at time 0
    y_vals = [current_state];   // Initial state

    // Sort transitions by time
    // Flatten the matrix
    transitions_flat = [];
    for i = 1:size(transitions, "r")
        transitions_flat = [transitions_flat, transitions(i, :)]; // Adiciona linha a linha
    end

    // Sort values and get indices
    [sorted_times, sorted_idx] = gsort(transitions_flat, "g", "i");

    // Calculate the row index for each sorted value
    originalRows = ceil(sorted_idx / size(transitions, "c"));

    // Iterate over the sorted times
    for i = 1:length(sorted_times)
        // Duplicate the current time to keep the state constant until the next transition
        times($ + 1) = sorted_times(i);   // Current transition time
        y_vals($ + 1) = y_vals($);        // Repeat the current state

        // Update time and state for the next step
        times($ + 1) = sorted_times(i);   // Transition time
        if originalRows(i) == 1 then
            current_state = 0;    // Red line -> yellow
        elseif originalRows(i) == 2 then
            current_state = 1;    // Green line -> red
        elseif originalRows(i) == 3 then
            current_state = 0.5;  // Yellow line -> green
        end
        y_vals($ + 1) = current_state;    // Update the state
    end

    // Add each graph as a subplot
    subplot(length(selected_signals), 1, subplot_idx); // Arrange subplots in a single column
    plot2d(times, y_vals, style = 2); // Use plot2d for steps (approx.)
    xtitle("Time (t)", "State (y)", ["Signal State Graph " + string(signal)]);
    //  xgrid();

    // Increment the subplot index
    subplot_idx = subplot_idx + 1;
end

